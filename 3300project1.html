<html>
<head>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<!-- Load the d3 library. -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>

<!-- Move to different file! -->
<style>
	.scxAxis, .scyAxis path {
		fill: none;
		stroke: black;
	}
	.scxAxis, .scyAxis text {
		font-size: 8px;
		font-family: "Open Sans";
	}
	body {
		font-family: "Open Sans";
	}

	.topstate{
	  	stroke: red;
	}

    .grid .tick {
    	stroke: #d3d3d3;
    	opacity: 0.001;
	}	

	.grid path {
		stroke-width: 0;
	}


</style>


</head>

<body>

<div id="map"></div>
<defs>
	<linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#fff;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#de2d26;stop-opacity:1" />
    </linearGradient>
</defs>

<div id="scatter"></div>

<script>
	/************ US Map ************/ 

	var mapWidth = 960,
	    mapHeight = 600;

	var projection = d3.geo.albersUsa();

	var path = d3.geo.path().projection(projection);
		
	var svg = d3.select("#map").append("svg")
	    .attr("width", mapWidth)
	    .attr("height", mapHeight);

	var digitScale = d3.scale.category10()
	var percentScale = d3.scale.linear().domain([1, 9, 15]).range(["#fff", "#edf8b1", "#ff0000"]);
	var popScale = d3.scale.linear().domain([500000,40000000]).range([15,35]);

	var states;

	var stateAtlas;

	d3.json("us.json", function(error, shapes) {
		states = topojson.feature(shapes, shapes.objects.states).features;

	var defs = svg.append("defs");


// Adapted from http://www.xanthir.com/b4Yv0; http://jsfiddle.net/kkPM4/
	var filter = defs.append("filter")
	    .attr("id", "inner-shadow")
	    .attr("height", "200%")
	    .attr("width", "200%")
	    .attr("x", "-50%")
	    .attr("y", "-50%")

	filter.append("feCompenentTransfer")
		.attr("in", "SourceAlpha")
		.append("feFuncA")
			.attr("type", "table")
			.attr("tableValues", "1 0")
	filter.append("feGaussianBlur")
	    .attr("stdDeviation", 0.5)

	filter.append("feOffset")
	    .attr("dx", -4)
	    .attr("dy", -4)
	    .attr("result", "offsetBlur")

    // filter.append("feFlood")
    // 	.attr("flood-color", "rgb(20,0,0)")
    // 	.attr("result", "color")

 //    filter.append("feComposite")
 //    	.attr("in", "offsetblur")
 //    	.attr("operator","in")
 //    filter.append("feComposite")
 //    	.attr("in", "SourceAlpha")
 //    	.attr("operator","in")

 //    // filter.append("feMerge");

	// var feMerge = filter.append("feMerge");
	// 	feMerge.append("feMergeNode")
	// 	    .attr("in", "offsetBlur")
	// 	feMerge.append("feMergeNode")
	// 	    .attr("in", "SourceGraphic");

// ---------insetshadow----------
	// var filter = defs.append("filter")
	//     .attr("id", "inset-shadow")
	//     // .attr("height", "200%")
	//     // .attr("width", "200%")
	//     // .attr("x", "-50%")
	//     // .attr("y", "-50%")

	// filter.append("feCompenentTransfer")
	// 	.attr("in", "SourceAlpha")
	// 	.attr("result", "inset-selection")
	// 	.append("feFuncA")
	// 		.attr("type", "discrete")
	// 		.attr("tableValues", "0 1 1 1 1 1")
	// filter.append("feCompenentTransfer")
	// 	.attr("in", "SourceAlpha")
	// 	.attr("result", "original-no-fill")
	// 	.append("feFuncA")
	// 		.attr("type", "discrete")
	// 		.attr("tableValues", "0 0 1")
	// filter.append("feColorMatrix")
	// 	.attr("type", "matrix")
	// 	.attr("in", "original-no-fill")
	// 	.attr("result", "new-source-alpha")
	// 	.attr("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0")

	// filter.append("feGaussianBlur")
	//     .attr("in", "SourceAlpha")
	//     .attr("result", "blur")
	//     .attr("stdDeviation", "5")
	// filter.append("feGaussianBlur")
	//     .attr("in", "SourceAlpha")
	//     .attr("result", "blur2")
	//     .attr("stdDeviation", "10")
	// filter.append("feGaussianBlur")
	//     .attr("in", "SourceAlpha")
	//     .attr("result", "blur3")
	//     .attr("stdDeviation", "15")

 //    filter.append("feMerge")

	// var feMerge = filter.append("feMerge");
	// 	feMerge.attr("result", "result")
	// 	feMerge.append("feMergeNode")
	// 	    .attr("in", "blur")
	// 	feMerge.append("feMergeNode")
	// 	    .attr("in", "blur2")
	// 	feMerge.append("feMergeNode")
	// 	    .attr("in", "blur3")

 //    filter.append("feComposite")
 //    	.attr("operator","in")
 //    	.attr("in", "inset-selection")
 //    	.attr("in2", "blur")
 //    	.attr("result", "inset-blur")
 //   	filter.append("feComposite")
 //    	.attr("operator","over")
 //    	.attr("in", "original-no-fill")
 //    	.attr("in2", "inset-blur")

	var statePaths = svg.append("g");
	statePaths.selectAll("path").data(states).enter()
	.append("path").attr("d", path)
	.style("fill", function (state) { return digitScale(state.Percent); });
		
	d3.csv("Graph1Data.csv", function (error, rows) {
		if (error) {console.log(error);}
		stateAtlas = d3.map(rows, function (state) { 
			return Number(state.Id); 
		});
			
		});

	var statePaths = svg.append("g");
	// var stateCircles = svg.append("g");
	var stateTags = svg.append("g");

	// stateCircles.selectAll("path").data(states).enter()
	// .append("circle")
	// .attr("cx",function(state){
	// 	return path.centroid(state)[0]
	// 	})
	// .attr("cy",function(state){
	// 	return path.centroid(state)[1]
	// 	})
	// .attr("id",function(state){
	// 	return state.id;
	// 	})
	// .attr("stroke","black")
	// .attr("stroke-width","0.25px")
	// .attr("opacity",0.8);

	stateTags.selectAll("path").data(states).enter()
	.append("text")
	.attr("x",function(state){
		return (path.centroid(state)[0])
		})
	.attr("y",function(state){
		if(state.id=="11"){ return path.centroid(state)[1]+5;}
		else{return path.centroid(state)[1]}
		})
	.attr("font-size","10px")
	.attr("id",function(state){
		return state.id;
		})
	.attr("text-anchor","middle")
	.attr("dominant-baseline","middle");

	statePaths.selectAll("path").data(states).enter()
	.append("path").attr("d", path)
	.style("stroke-width",1.5);

	
	d3.csv("Graph1Data.csv", function (error, rows) {
	if (error) {console.log(error);}
		
		stateAtlas = d3.map(rows, function (state) { 
			return Number(state.Id); 
		});

		statePaths.selectAll("path")
		.style("fill",
			function(state) {
				var stateData = stateAtlas.get(state.id);
				if(!stateData) {return "none";}
				return percentScale(stateData.Percent);
			})
		.attr("class",function(state){
			var stateData = stateAtlas.get(state.id);
			if(!stateData) {return "none";}
			if(stateData.Percent <= 7.6){
				return "topstate";
			}
			if(stateData.Percent>=13.1){
				return "topstate";
			}else{
				return "botstate";
			}
		})
		.style("filter",
			function(state){
				var stateData = stateAtlas.get(state.id);
				if(!stateData){return "none";}
				if(stateData.Percent<=7.6){
					return "url(#inner-shadow)";
				}
				if(stateData.Percent>=13.1){
					return "url(#inner-shadow)";
				}else{
					return "none";
				}
			});

		// stateCircles.selectAll("circle")
		// .style("fill",
		//  	function(circle){
		// 		var stateData = stateAtlas.get(circle.id)
		// 		if (! stateData) {return "none";}
		// 		return percentScale(stateData.Percent);
		//  	})
		// .style("r",
		// 	function(circle){
		// 		var stateData = stateAtlas.get(circle.id)
		// 		if (! stateData) {return "none";}
		// 		return popScale(stateData.Population);
		// 	});
		
		stateTags.selectAll("text")
		.text(function(text){
			var stateData = stateAtlas.get(text.id)
			if (!stateData) {return "none";}
			return stateData.Tag;
		})
		.attr("font-weight","bold");
	});
		
});


	// Problem: ticks are too far to right
	/************ Scatter Plot ************/ 
	var scMargin = {top: 20, right: 20, bottom: 30, left: 40}
	var scatterWidth = 800 - scMargin.left - scMargin.right
	var scatterHeight = 400 - scMargin.top - scMargin.bottom

	var scatterxVal = function(d) { return d.Percent; },
		scatterxScale = d3.scale.linear().range([0, scatterWidth]),
		scatterxMap = function(d) { return scatterxScale(scatterxVal(d)); },
		scatterxAxis = d3.svg.axis().scale(scatterxScale).orient("bottom");

	var scatteryVal = function(d) { return d.Income; },
		scatteryScale = d3.scale.linear().range([scatterHeight,0]),
		scatteryMap = function(d) { return scatteryScale(scatteryVal(d)); },
		scatteryAxis = d3.svg.axis()
						.scale(scatteryScale).orient("left")
						.ticks(10);


	var scattersvg = d3.select("body").append("svg")
		.attr("width", scatterWidth	+ scMargin.left + scMargin.right )
		.attr("height", scatterHeight + scMargin.top + scMargin.bottom )
		.append ("g")
			.attr("transform", "translate(" + scMargin.left + "," + scMargin.top + ")");

	// Fill Color
	var scatterCVal = function(d) { return d.Id; };
	var color = d3.scale.category20c();


	d3.csv("Graph1Data.csv", function (error, rows) {
		if (error) {console.log(error);}
		rows.forEach(function(d) {
			d.Income = +d.Income;
			d.Percent = +d.Percent;
		});

		scatterxScale.domain([d3.min(rows, scatterxVal)-1, d3.max(rows, scatterxVal)+1]);
		scatteryScale.domain([d3.min(rows, scatteryVal)-1, d3.max(rows, scatteryVal)+1]);

		// scattersvg.selectAll(".dot")
		// 	.data(rows)
		// 	 .enter().append("circle")
		// 	 .attr("class", "dot")
		// 	 .attr("r", function (d) {
		// 	 	return (d.pVeterans)
		// 	 })
		// 	 .attr("cx", scatterxMap)
		// 	 .attr("cy", scatteryMap)
		// 	 // .style("fill", function(d) {
		// 	 // 	return color(scatterCVal(d)%20);
		// 	 // });
		// 	.style("fill", function(d) {
		// 		return percentScale(d.Percent)
		// 	});

		// scattersvg.selectAll("text")
		// 	.data(rows)
		// 	.enter()
		// 	.append("text")
		// 	.text(function(d) {
		// 		return d.Tag;
		// 	})
		// 	.attr("x", function(d) {
		// 		return scatterxMap(d);
		// 	})
		// 	.attr("y", function(d) {
		// 		return scatteryMap(d);
		// 	})
		// 	.attr("font-size", "8px");

		// Creating x,y axis
		 scattersvg.append("g") 
		 	.attr("class", "scxAxis")
		 	.attr("transform", "translate(0," + scatterHeight + ")")
		 	.call(scatterxAxis);
		 scattersvg.append("g")
		 	.attr("class", "scyAxis")
		 	.call(scatteryAxis);


		// Creating grid lines
		var numTicks = 10

		var yAxisGrid = scatteryAxis.ticks(numTicks)
			.tickSize(scatterWidth, 0)
			.tickFormat("")
			.orient("right");
		var xAxisGrid = scatterxAxis.ticks(numTicks)
			.tickSize(-scatterHeight, 0)
			.tickFormat("")
			.orient("top");
		scattersvg.append("g")
			.attr("class", "grid")
			.call(yAxisGrid)
		scattersvg.append("g")
			.attr("class", "grid")
			.call(xAxisGrid)


		scattersvg.selectAll(".dot")
			.data(rows)
			 .enter().append("circle")
			 .attr("class", "dot")
			 .attr("r", function (d) {
			 	return (d.pVeterans)
			 })
			 .attr("cx", scatterxMap)
			 .attr("cy", scatteryMap)
			 // .style("fill", function(d) {
			 // 	return color(scatterCVal(d)%20);
			 // });
			.style("fill", function(d) {
				return percentScale(d.Percent)
			});
console.log(rows);
		scattersvg.selectAll("text")
			.data(rows)
			.enter()
			.append("text")
			.text(function(d) {
				console.log(d.Tag);
				return d.Tag;
			})
			.attr("x", function(d) {
				return scatterxMap(d);
			})
			.attr("y", function(d) {
				return scatteryMap(d);
			})
			.attr("font-size", "8px")
console.log(rows);
	});
	function makeXGrid() {
		console.log("xcalled")
		return d3.svg.axis()
			.scale(scatterxVal)
			.orient("bottom")
			.ticks(10)
	}
	function makeYGrid() {
		console.log("ycalled")
		return d3.svg.axis()
			.scale(scatteryVal)
			.orient("left")
			.ticks(10)
	}
</script>
</body>
</html>
