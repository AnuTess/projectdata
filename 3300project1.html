<html>
<head>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<!-- Load the d3 library. -->
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>

<!-- Move to different file! -->
<style>
	.scxAxis, .scyAxis path {
		fill: none;
		stroke: black;
	}
	.scxAxis, .scyAxis text {
		font-size: 8px;
		font-family: "Open Sans";
	}
	body {
		font-family: "Open Sans";
	}
	text{
		font-family:"Open Sans";
	}
</style>


</head>

<body>
<div id="map"></div>
<defs>
	<linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:#fff;stop-opacity:1" />
      <stop offset="100%" style="stop-color:#de2d26;stop-opacity:1" />
    </linearGradient>
</defs>


	<div id="map"></div>

	<div id="scatter"></div>


	<script>

	/************ US Map ************/ 

	var mapWidth = 960,
	    mapHeight = 500;

	var projection = d3.geo.albersUsa();

	var path = d3.geo.path().projection(projection);
		
	var svg = d3.select("#map").append("svg")
	    .attr("width", mapWidth)
	    .attr("height", mapHeight);

	var digitScale = d3.scale.category10()
	var percentScale = d3.scale.linear().domain([1, 10, 15]).range(["#fff", "#fdae6b", "#de2d26"]);
	var popScale = d3.scale.linear().domain([500000,40000000]).range([15,35]);

	var states;

	var digitScale = d3.scale.category10()
	var percentScale = d3.scale.linear().domain([0, 10, 15]).range(["#fee0d2", "#fc9272", "#de2d26"]);

	var stateAtlas;

	d3.json("us.json", function(error, shapes) {
		states = topojson.feature(shapes, shapes.objects.states).features;

		var statePaths = svg.append("g");
		statePaths.selectAll("path").data(states).enter()
		.append("path").attr("d", path)
		.style("fill", function (state) { return digitScale(state.Percent); })
		.style("stroke", "#ccc");
		
		d3.csv("Graph1Data.csv", function (error, rows) {
		if (error) {console.log(error);}
			
			// what should we do with the CSV data?
			stateAtlas = d3.map(rows, function (state) { 
				return Number(state.Id); 
			});
			
			statePaths.selectAll("path")
			.style("fill", function (state) {
				var stateData = stateAtlas.get(state.id);
				console.log("stateData for "+state.id +" is "+stateData);
				if (! stateData) {return "none";}
				for (var x=0; x<49; x++){
					console.log("id " + stateData.Id+", name " +stateData.State+", percent "+stateData.Percent);
				}
				return percentScale(stateData.Percent);
			});
			
		});
			
	var statePaths = svg.append("g");
	// var stateCircles = svg.append("g");
	var stateTags = svg.append("g");

	// stateCircles.selectAll("path").data(states).enter()
	// .append("circle")
	// .attr("cx",function(state){
	// 	return path.centroid(state)[0]
	// 	})
	// .attr("cy",function(state){
	// 	return path.centroid(state)[1]
	// 	})
	// .attr("id",function(state){
	// 	return state.id;
	// 	})
	// .attr("stroke","black")
	// .attr("stroke-width","0.25px")
	// .attr("opacity",0.8);

	stateTags.selectAll("path").data(states).enter()
	.append("text")
	.attr("x",function(state){
		return (path.centroid(state)[0])
		})
	.attr("y",function(state){
		if(state.id=="11"){ return path.centroid(state)[1]+5;}
		else{return path.centroid(state)[1]}
		})
	.attr("font-size","10px")
	.attr("id",function(state){
		return state.id;
		})
	.attr("text-anchor","middle")
	.attr("dominant-baseline","middle");

	statePaths.selectAll("path").data(states).enter()
	.append("path").attr("d", path)
	.style("stroke", "#000")
	.style("stroke-opacity",1)
	.style("stroke-width",2)
	.style("font-weight","bold")
	.style("fill","none");

	
	d3.csv("Graph1Data.csv", function (error, rows) {
	if (error) {console.log(error);}
		
		stateAtlas = d3.map(rows, function (state) { 
			return Number(state.Id); 
		});

		statePaths.selectAll("path")
		.style("stroke",
			function (state) {
				var stateData = stateAtlas.get(state.id);
				if (! stateData) {return "none";}
			// for (var x=0; x<49; x++){
			// 	console.log("id " + stateData.Id+", name " +stateData.State+", percent "+stateData.Percent);
			// }
				return percentScale(stateData.Percent);
			})
		.style("fill",
			function(state) {
				var stateData = stateAtlas.get(state.id);
				if(!stateData) {return "none";}
				return percentScale(stateData.Percent);
			});

		// stateCircles.selectAll("circle")
		// .style("fill",
		//  	function(circle){
		// 		var stateData = stateAtlas.get(circle.id)
		// 		if (! stateData) {return "none";}
		// 		return percentScale(stateData.Percent);
		//  	})
		// .style("r",
		// 	function(circle){
		// 		var stateData = stateAtlas.get(circle.id)
		// 		if (! stateData) {return "none";}
		// 		return popScale(stateData.Population);
		// 	});
		
		stateTags.selectAll("text")
		.text(function(text){
			var stateData = stateAtlas.get(text.id)
			if (!stateData) {return "none";}
			return stateData.Tag;
		});
	});
		
});

/************ Scatter Plot ************/ 
var scMargin = {top: 20, right: 20, bottom: 30, left: 40}
var scatterWidth = 800 - scMargin.left - scMargin.right
var scatterHeight = 400 - scMargin.top - scMargin.bottom

var scatterxVal = function(d) { return d.Percent; },
	scatterxScale = d3.scale.linear().range([0, scatterWidth]),
	scatterxMap = function(d) { return scatterxScale(scatterxVal(d)); }
	scatterxAxis = d3.svg.axis().scale(scatterxScale).orient("bottom");

var scatteryVal = function(d) { return d.Income; },
	scatteryScale = d3.scale.linear().range([scatterHeight,0]),
	scatteryMap = function(d) { return scatteryScale(scatteryVal(d)); },
	scatteryAxis = d3.svg.axis().scale(scatteryScale).orient("left");

var scattersvg = d3.select("body").append("svg")
	.attr("width", scatterWidth	+ scMargin.left + scMargin.right )
	.attr("height", scatterHeight + scMargin.top + scMargin.bottom )
	.append ("g")
		.attr("transform", "translate(" + scMargin.left + "," + scMargin.top + ")");

// Fill Color
var scatterCVal = function(d) { return d.Id; };
var color = d3.scale.category20c();

d3.csv("Graph1Data.csv", function (error, rows) {
	if (error) {console.log(error);}
	rows.forEach(function(d) {
		d.Income = +d.Income;
		d.Percent = +d.Percent;
	});

	// Problem: ticks are too far to right
	/************ Scatter Plot ************/ 
	var scMargin = {top: 20, right: 20, bottom: 30, left: 40}
	var scatterWidth = 800 - scMargin.left - scMargin.right
	var scatterHeight = 400 - scMargin.top - scMargin.bottom

	var scatterxVal = function(d) { return d.Percent; },
		scatterxScale = d3.scale.linear().range([0, scatterWidth]),
		scatterxMap = function(d) { return scatterxScale(scatterxVal(d)); }
		scatterxAxis = d3.svg.axis().scale(scatterxScale).orient("bottom");

	var scatteryVal = function(d) { return d.Income; },
		scatteryScale = d3.scale.linear().range([scatterHeight,0]),
		scatteryMap = function(d) { return scatteryScale(scatteryVal(d)); },
		scatteryAxis = d3.svg.axis().scale(scatteryScale).orient("left");


	var scattersvg = d3.select("body").append("svg")
		.attr("width", scatterWidth	+ scMargin.left + scMargin.right )
		.attr("height", scatterHeight + scMargin.top + scMargin.bottom )
		.append ("g")
			.attr("transform", "translate(" + scMargin.left + "," + scMargin.top + ")");

	// Fill Color
	var scatterCVal = function(d) { return d.Id; };
	var color = d3.scale.category20c();

	d3.csv("Graph1Data.csv", function (error, rows) {
		if (error) {console.log(error);}
		rows.forEach(function(d) {
			d.Income = +d.Income;
			d.Percent = +d.Percent;
		});

		scatterxScale.domain([d3.min(rows, scatterxVal)-1, d3.max(rows, scatterxVal)+1]);
		scatteryScale.domain([d3.min(rows, scatteryVal)-1, d3.max(rows, scatteryVal)+1]);

		scattersvg.selectAll(".dot")
			.data(rows)
			 .enter().append("circle")
			 .attr("class", "dot")
			 .attr("r", function (d) {
			 	return (d.pVeterans)
			 })
			 .attr("cx", scatterxMap)
			 .attr("cy", scatteryMap)
			 // .style("fill", function(d) {
			 // 	return color(scatterCVal(d)%20);
			 // });
			.style("fill", function(d) {
				return percentScale(d.Percent)
			});

		scattersvg.selectAll("text")
			.data(rows)
			.enter()
			.append("text")
			.text(function(d) {
				return d.Tag + "\t" + d.Percent;
			})
			.attr("x", function(d) {
				return scatterxMap(d);
			})
			.attr("y", function(d) {
				return scatteryMap(d);
			})
			.attr("font-size", "8px");

		 scattersvg.append("g") 
		 	.attr("class", "scxAxis")
		 	.attr("transform", "translate(0," + scatterHeight + ")")
		 	.call(scatterxAxis);
		 scattersvg.append("g")
		 	.attr("class", "scyAxis")
		 	.call(scatteryAxis);
	

	});
});
</script>
</body>
</html>
